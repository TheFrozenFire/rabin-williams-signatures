// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {RabinWilliamsVerifier} from "../src/RabinWilliamsVerifier.sol";

contract RabinWilliamsVerifierTest is Test {
    RabinWilliamsVerifier public verifier;

    // Fixture data loaded from CLI output
    bytes public n; // public key modulus
    bytes public message;
    bytes public signature;

    function setUp() public {
        verifier = new RabinWilliamsVerifier();
        
        // Load fixtures generated by CLI
        // Paths are relative to project root
        string memory publicKeyHex = vm.readFile("contracts/test/fixtures/public_key.hex");
        string memory messageText = vm.readFile("contracts/test/fixtures/message.txt");
        string memory signatureHex = vm.readFile("contracts/test/fixtures/signature.hex");
        
        // Convert hex strings to bytes
        n = hexStringToBytes(publicKeyHex);
        message = bytes(messageText);
        signature = hexStringToBytes(signatureHex);
    }

    function test_VerifySignature() public {
        console.log("n length:", n.length);
        console.log("message length:", message.length);
        console.log("signature length:", signature.length);
        console.log("First signature byte:", uint8(signature[0]));
        
        // Compute message hash
        bytes32 messageHash = sha256(message);
        console.log("Expected hash:");
        console.logBytes32(messageHash);
        
        // Verify using Rust CLI to double-check
        bool isValid = verifier.verify(n, message, signature);
        console.log("Verification result:", isValid);
        
        assertTrue(isValid, "Signature should be valid");
    }
    
    function test_DebugVerification() public view {
        // This will help us debug what's happening
        bytes32 messageHash = sha256(message);
        console.log("Message hash (32 bytes):");
        console.logBytes32(messageHash);
        
        // We can't easily debug the internal computation without exposing more functions
        // But we can verify the inputs are correct
        console.log("n (first 32 bytes):");
        bytes memory nPrefix = new bytes(32);
        for (uint256 i = 0; i < 32 && i < n.length; i++) {
            nPrefix[i] = n[i];
        }
        console.logBytes(nPrefix);
    }

    function test_VerifyInvalidSignature() public view {
        // Tamper with signature
        bytes memory tamperedSignature = new bytes(signature.length);
        for (uint256 i = 0; i < signature.length; i++) {
            tamperedSignature[i] = signature[i];
        }
        tamperedSignature[1] = bytes1(uint8(tamperedSignature[1]) ^ 1);
        
        bool isValid = verifier.verify(n, message, tamperedSignature);
        assertFalse(isValid, "Tampered signature should be invalid");
    }

    function test_VerifyWrongMessage() public view {
        bytes memory wrongMessage = "Wrong message";
        bool isValid = verifier.verify(n, wrongMessage, signature);
        assertFalse(isValid, "Signature should be invalid for wrong message");
    }

    /**
     * @notice Converts a hex string to bytes
     * @dev Removes whitespace and converts hex string to bytes
     */
    function hexStringToBytes(string memory hexString) internal pure returns (bytes memory) {
        // Remove any whitespace/newlines
        bytes memory hexBytes = bytes(hexString);
        bytes memory result = new bytes(hexBytes.length / 2);
        
        uint256 j = 0;
        for (uint256 i = 0; i < hexBytes.length; i += 2) {
            // Skip whitespace
            while (i < hexBytes.length && (hexBytes[i] == 0x20 || hexBytes[i] == 0x0A || hexBytes[i] == 0x0D)) {
                i++;
            }
            if (i >= hexBytes.length - 1) break;
            
            uint8 high = charToHex(hexBytes[i]);
            uint8 low = charToHex(hexBytes[i + 1]);
            result[j++] = bytes1((high << 4) | low);
        }
        
        // Resize result to actual length
        assembly {
            mstore(result, j)
        }
        
        return result;
    }

    function charToHex(bytes1 char) internal pure returns (uint8) {
        if (char >= 0x30 && char <= 0x39) {
            return uint8(char) - 0x30;
        } else if (char >= 0x41 && char <= 0x46) {
            return uint8(char) - 0x37;
        } else if (char >= 0x61 && char <= 0x66) {
            return uint8(char) - 0x57;
        }
        revert("Invalid hex character");
    }
}

